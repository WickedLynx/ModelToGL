//
//  TGLViewController.m
//  TestGL
//
//  Created by Harshad on 03/04/14.
//  Copyright (c) 2014 Laughing Buddha Software. All rights reserved.
//

#import "TGLViewController.h"

// Import the header generated by ModelToGL
#import "Pencil.h"

@interface TGLViewController () {
    GLuint _bufferID;   // The buffer id to store the vertex data
    GLfloat _rotate;    // The rotation angle
}

@property (strong, nonatomic) GLKBaseEffect *baseEffect;

@end

@implementation TGLViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
	// Do any additional setup after loading the view, typically from a nib.
    
    // The view controller's view is a GLKView (set up in the storyboard)
    GLKView *view = (GLKView *)self.view;
    // Be the view's delegate
    [view setDelegate:self];

    // Create a EAGLContext and set it as the view' context
    EAGLContext *currentContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
    [view setContext:currentContext];
    
    // Make the EAGLContext of the view the current context
    [EAGLContext setCurrentContext:currentContext];

    // Create a base effect
    _baseEffect = [[GLKBaseEffect alloc] init];
    
    // Load the texture image
    CGImageRef pencilTexture = [[UIImage imageNamed:@"Pencil.png"] CGImage];
    GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithCGImage:pencilTexture options:@{GLKTextureLoaderOriginBottomLeft : @YES} error:NULL];
    [self.baseEffect.texture2d0 setName:textureInfo.name];
    [self.baseEffect.texture2d0 setTarget:textureInfo.target];
    [self.baseEffect.texture2d0 setEnabled:YES];

    // Set the background color to gray
    glClearColor(0.75f, 0.75f, 0.75f, 1.0f);

    // Generate buffer for the pencil
    glGenBuffers(1, &_bufferID);
    
    // Bind the generated buffer
    glBindBuffer(GL_ARRAY_BUFFER, _bufferID);

    // Copy the vertex data for the Pencil model to the generated buffer
    glBufferData(GL_ARRAY_BUFFER, sizeof(PencilTriangles), PencilTriangles, GL_DYNAMIC_DRAW);

    // Do not draw hidden faces
    glEnable(GL_CULL_FACE);
    
    // Turn on the lights!
    [_baseEffect.light0 setEnabled:YES];
    [_baseEffect.light0 setPosition:GLKVector4Make(1.0f, 1.0f, 1.0f, 1.0f)];
    [_baseEffect.light0 setDiffuseColor:GLKVector4Make(1.0f, 1.0f, 1.0f, 1.0f)];
    [_baseEffect.light0 setAmbientColor:GLKVector4Make(1.0f, 1.0f, 1.0f, 1.0f)];
    [_baseEffect setLightingType:GLKLightingTypePerPixel];

}

- (void)update {
    // Increases the rotation angle every frame
    _rotate += 1.0f;
}

- (void)setMatrices
{

    // Set the projection matrix
    // Aspect ratio correction
    const GLfloat aspectRatio = (GLfloat)(self.view.bounds.size.width) / (GLfloat)(self.view.bounds.size.height);
    // Set the field of view
    const GLfloat fieldView = GLKMathDegreesToRadians(90.0f);
    const GLKMatrix4 projectionMatrix = GLKMatrix4MakePerspective(fieldView, aspectRatio, 0.1f, 10.0f);
    _baseEffect.transform.projectionMatrix = projectionMatrix;

    // Set the model view matrix
    GLKMatrix4 modelViewMatrix = GLKMatrix4Identity;
    modelViewMatrix = GLKMatrix4Translate(modelViewMatrix, -1.5f, 0.0f, -5.0f);
    modelViewMatrix = GLKMatrix4RotateX(modelViewMatrix, GLKMathDegreesToRadians(_rotate));
    modelViewMatrix = GLKMatrix4RotateY(modelViewMatrix, GLKMathDegreesToRadians(45));
    modelViewMatrix = GLKMatrix4RotateZ(modelViewMatrix, GLKMathDegreesToRadians(_rotate));
    _baseEffect.transform.modelviewMatrix = modelViewMatrix;
}

- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {
    
    // Clear everything
    glClear(GL_COLOR_BUFFER_BIT);
    
    // Prepare the base effect
    [self.baseEffect prepareToDraw];

    // Set up the projection and model view matrices
    [self setMatrices];

    // Enable the position arrays
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(MTGSceneVertex), NULL + offsetof(MTGSceneVertex, positions));

    // Enable the texture arrays
    glEnableVertexAttribArray(GLKVertexAttribTexCoord0);
    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(MTGSceneVertex), NULL + offsetof(MTGSceneVertex, texels));
    
    // Enable the normal arrays
    glEnableVertexAttribArray(GLKVertexAttribNormal);
    glVertexAttribPointer(GLKVertexAttribNormal, 3, GL_FLOAT, GL_FALSE, sizeof(MTGSceneVertex), NULL + offsetof(MTGSceneVertex, normals));

    // Draw!
    glDrawArrays(GL_TRIANGLES, 0, sizeof(PencilTriangles)/ sizeof(MTGSceneVertex));
}



@end

